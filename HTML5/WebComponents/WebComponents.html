<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8" />
<title>Web Components  </title>
<style type="text/css">
h1{ font-size:24px; font-weight:bold; color:rgb(50,50,250); margin-left:20px;} 
h2{ font-size:18px; font-weight:bold; color:rgb(250,50,150); margin-left:20px;}
h3{ font-size:14px; font-weight:bold; color:rgb(200,20,20); margin-left:20px;}
code, pre{ color:rgb(20,150,30); font-weight:bold; background:rgb(230,230,230); margin:5px; padding:5px;}
dt{ color:#003399; margin-bottom:5px;}
p{
margin:10px;
}

.nota{ color:rgb(250,120,0);}
.grigio{color:gray;}
.azzurro{color:rgb(50,100,255);}
.scuro{color:#333;}

.codice{ color:rgb(30,120,30);}		
dd{ color:#0066FF;}

div.divo{
width:500px; height:350px; background:yellow;
}

</style>
</head>
<body>

<h1>Web Components</h1>

<p>
I <q>Web components</q> sono composti da quattro pezzi ideati per essere utilizzati insieme che permettono agli autori di definire dei widgets ad un livello che oggi non è possibile fare con i CSS e che risultano essere facili da utilizzare e riutilizzare ancor meglio di quello che ci permettono le librerie. 
I quattro pezzi sono:
<dl>
	<dt><b>templates</b>: pezzi di markup inerti che possono essere utilizzati quando lo si vuole</dt>
	<dt><b>custom elements</b>: che permettono agli autori di definire degli elementi personalizzati da inserirre nel documento </dt>
	<dt><b>shadow DOM</b>: che permettono di definire presentazione e comportamento dei <q>decorators</q> e <q>custom elements</q> all'interno del DOM   </dt>
	<dt><b>HTML Import</b>:  </dt>
</dl>	
</p>

<h2>Templates</h2>
<p>
L'elemento &lt;template&gt; contiene markup inteso per essere utilizzando in un secondo momento. Il suo contenuto viene analizzato dal parser ma rimane inerte nel senso che i suoi scripts (al suo interno) non vengono processati cosi come non vengono scaricate le sue immagtini ecc.. In altre parole l'elemento non viene restituito. <br />
L'elemento &lt;template&gt; ha una proprietà chiamata <b>content</b> che contiene il contenuto dell'elemento &lt;template&gt; in un <q>document fragment</q>. Quindi quando si vuole utilizzare questo contenuto lo si può spostare e copiare come un semplice nodo.  

<pre>
&lt;template id="commentTemplate"&gt;
	&lt;div&gt; 
		&lt;img src=""&gt;
		&lt;div class="comment-text"&gt;&lt;/div&gt; 
	&lt;/div&gt; 
&lt;/template&gt; 

function addComment(imageUrl, text) {
	var t = document.querySelector("#commentTemplate");
	var comment = t.content.cloneNode(true);
	comment.querySelector('img').src = imageUrl;
	comment.querySelector('.comment-text').textContent = text;
	document.body.appendChild(comment);
}
</pre>

Ciò che è contenuto nell'elemento &lt;template&gt; non sta nel documento ma in <q>document fragment</q>. Per cui aggiungendo una copia del contenuto del &lt;template&gt; in un medesimo istante lo rende attivo solo in quel punto in quel momento .   
</p>

<h2>Custom Elements</h2>
<p>
I <q>custom elements</q> (<b>elementi personalizzati</b>) sono elementi HTML definiti dall'autore. Possono essere creati con il metodo <b>registerElement</b>:
<pre>
var XFoo = document.registerElement('x-foo');
document.body.appendChild(new XFoo());  
</pre>
Nell'esempio si nota un solo argomento che è il nome dell'elemento tag. C'è l'obbligo di raprresentare questo nome con un trattivo ( - ). Per esempio &lt;mio-tag&gt; oppure &lt;mio-elemento&gt; o &lt;la-mia-app&gt; ecc.. Mentre nomi tipo &lt;mioTag&gt; o &lt;mioelemento&gt; non sono accettati. <br />
L'esempio di sopra sarebbe equivalente al seguente:
<pre>
var XFoo = document.registerElement('x-foo', {
	prototype: Object.create(HTMLElement.prototype)
});
</pre>
</p>

<h3>Estensione di elementi personalizzati</h3>
<p>I <q>custom elements</q> danno la possibilità di estendere elementi sia da elementi nativi (div, button, p ecc..) che da altri elementi personalizzati (custom elements) sfruttando l'ereditarietà del prototype e l'uso della proprietà <b>extends</b>.    
<pre>
<span class="nota">Estensione da un elemento nativo</span> 
var MegaButton = document.registerElement('mega-button', {
	prototype: Object.create(HTMLButtonElement.prototype),
	extends: 'button'
});
</pre>
Nell'esempio l'elemento personalizzato <q>mega-button</q> eredità il prototype dell'elemento (nativo) &lt;button&gt;. <br />
Gli elementi personalizzati che ereditano da elementi nativi (come in quest'ultimo caso) sono detti <b>type extension custom elements</b> (elementi personalizzati con estensioni di tipo). <br />
Dall'esempio precedente di cui sopra si avrebbe in una raprresntazione HTML :
<pre>
&lt;button is="mega-button"&gt; 
</pre>
</p>

<p>
Per creare un elemento personalizzato che si estende da un'altro elemento personalizzato il procedimento è simile a quello visto sopra
<pre>
<span class="nota">Estensione da un elemento personalizzato ad un'altro</span> 
var XFooProto = Object.create(HTMLElement.prototype);
...

var XFooExtended = document.registerElement('x-foo-extended', {
	prototype: XFooProto,
	extends: 'x-foo'
});
</pre>
</p>

<h3>HTMLElement e HTMLUnknownElement </h3>
<p>
L'HTML nella sue specifiche definisce degli elementi nativi quali &lt;div&gt;, &lt;p&gt;,  &lt;span&gt;, &lt;h1&gt;, &lt;h2&gt; ecc... Però se noi dovessimo inserire nel documento un elemento che non è fra i specificati (es: &lt;randomtag&gt; o &lt;miotago&gt; ecc..  ) tale elemento risulta comunque valido ma va a far parte degli <q>elementi non riconosciuti</q>  (HTMLUnknownElement). A differenza però gli elementi personalizzati vanno a far parte degli HTMLElement, qualora il browser li supporta altrimenti rientrano nella categoria degli HTMLUnknownElement. Ciò lo si può verificare con i seguenti 
<pre>
<span class="nota">dichiarazione di un elemento sconosciuto</span>
document.createElement('tabs').__proto__ === HTMLUnknownElement.prototype		<span class="nota">// true </span>

<span class="nota">dichiarazione di un elemento personalizzato</span>
document.createElement('x-tabs').__proto__ == HTMLElement.prototype			<span class="nota">// true </span>
</pre>
<b>Va detto che se un elemento personalizzato viene dichiarato (o creato nello scipt) ma non registrato fa sempre parte degli HTMLElement ma è detto <q>Unresolved element</q> </b>
</p>

<h3>Instanziare gli elementi personalizzati</h3>
<p>
Cosi come per gli elementi normali anche per quelli personalizzati si possono usare le stesse tecniche 
<pre>
<span class="nota">Dichiarazione HTML</span>
&lt;x-foo&gt;&lt;/x-foo&gt;  

<span class="nota">Con l'uso di Javascript</span>
var xFoo = document.createElement('x-foo');
var testo = document.createTextNode('Sono x-foo');
xFoo.appendChild(testo);
document.body.appendChild(xFoo);
xFoo.addEventListener('click', function(e) {
	alert('Hello jo!');
});

<span class="nota">Con l'utilizzo dell'operatore <q>new</q> </span>
var xFoo = new XFoo();
document.body.appendChild(xFoo);
</pre>
</p>

<h3>Instanziare elementi con estensione tipo (che si estendono da elementi nativi)</h3>
<pre>
<span class="nota">Dichiarazione HTML di un elemento personalizzato (mega-button) che si estende da un elemento nativo &lt;button&gt; </span>
&lt;button is="mega-button"&gt; 

<span class="nota">Con l'uso di Javascript</span>
var megaButton = document.createElement('button', 'mega-button');

<span class="nota">Con l'utilizzo dell'operatore <q>new</q> </span>
var megaButton = new MegaButton();
document.body.appendChild(megaButton);
</pre>

<h2>Aggiunta di proprietà e metodi</h2>
<p>
Una caratteristica importante dei <q>custom elements</q> è quella di poter definire proprietà e metodi all'elemento personalizzato quando lo si registra. La si può pensare come una pratica per poter creare una API per il proprio elemento. Quello che segue è un esempio distinto in varie parti
<pre>
var XFooProto = Object.create(HTMLElement.prototype);

<span class="nota">1. Give x-foo a foo() method.</span>
XFooProto.foo = function() {
	alert('foo() called');
};

<span class="nota">2. Define a property read-only "bar".</span>
Object.defineProperty(XFooProto, "bar", {value: 5});				
<span class="azzurro"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">vedere qui</a> per il metodo defineProperty</span>

<span class="nota"> 3. Register x-foo's definition.</span>
var XFoo = document.registerElement('x-foo', {prototype: XFooProto});

<span class="nota"> 4. Instantiate an x-foo.</span>
var xfoo = document.createElement('x-foo');

<span class="nota">5. Add it to the page.</span>
document.body.appendChild(xfoo);
</pre>

Quello che segue è invece un modo per condensare varie definizioni in un solo blocco
 
<pre>
var XFoo = document.registerElement('x-foo', {
	prototype: Object.create(HTMLElement.prototype, {
		bar: {
			get: function() { return 5; }
		},
		foo: {
			value: function() {
				alert('foo() called');
			}
		}
	})
});
</pre>

<span class="azzurro"> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/get">vedere qui per il metodo get</a>  </span>
</p>

<h3>Metodi Lifecycle callback</h3>
<p>
Gli elementi personalizzati possono definire dei metodi speciali che permettono di intercettare momenti particolari della loro esistenza. Questio metodi sono propriamente detti <q>lifecycle callback</q>. Ognuno di essi rappresenta un suo proposito

<dl>
	<dt><b>createdCallback</b>: scatta quando una istanza dell'elemento viene creata</dt>
	<dt><b>attachedCallback</b>: scatta quando l'istanza viene inserita nel documento </dt>
	<dt><b>detachedCallback</b>: scatta quando l'istanza viene rimossa dal documento</dt>
	<dt><b>attributeChangedCallback(attrName, oldVal, newVal)</b>: scatta quando un'attributo viene aggiunto, rimosso o aggiornato </dt>
</dl>	

<pre>
var proto = Object.create(HTMLElement.prototype);

proto.createdCallback = function() {...};
proto.attachedCallback = function() {...};

var XFoo = document.registerElement('x-foo', {prototype: proto});

proto.createdCallback = function() {
	this.addEventListener('click', function(e) {
		alert('Thanks!');
  });
};

</pre>
 
Il seguente è un modo per creare un elemento ed aggiungergli del testo. Utilizzando il metodo <q>createdCallback </q> possiamo indiririzzare il browser ad aggiungere il testo solo dopo che l'elemento è stato creato
<pre>
var XFooProto = Object.create(HTMLElement.prototype);

XFooProto.createdCallback = function() {
	this.innerHTML = "<b>I'm an x-foo-with-markup!</b>";
};

var XFoo = document.registerElement('x-foo-with-markup', {prototype: XFooProto});

<span class="nota">quello che risulterà sarà il seguente markup</span>
&lt;x-foo-with-markup&gt; 
	&lt;b&gt;I'm an x-foo-with-markup!&lt;/b&gt;  
&lt;/x-foo-with-markup&gt; 
</pre>


</p>






<br />
<br />
<br />


<x-foo-with-markup></x-foo-with-markup>
<br />
<br />


<script type="text/javascript">

/*
//## Inserire un elemento <template> nel <div> esistente 'divo'
var t = document.querySelector("#commentTemplate");
t.content.querySelector('img').src = "../img/olive2.jpg";
var clono = document.importNode(t.content, true);
var divo = document.querySelector('.divo');
divo.appendChild(clono);
//document.body.appendChild(clono);

function addComment(imageUrl, text) {
	var t = document.querySelector("#commentTemplate");
	var comment = t.content.cloneNode(true);
	comment.querySelector('img').src = imageUrl;
	comment.querySelector('.comment-text').textContent = text;
	document.body.appendChild(comment);
}
//## Inserire lo stesso elemento '<template> nel <body>
addComment("../img/olive2.jpg", 'bye');
*/

//var b = document.createElement('button', 'fancy-button');
//alert(b.outerHTML);

//var xf = document.querySelector('x-foo');


var xFoo = document.createElement('x-foo');
var testo = document.createTextNode('Sono x-foo');
xFoo.appendChild(testo);
//var xFoo = new XFoo();
document.body.appendChild(xFoo);

xFoo.addEventListener('click', function(e) {
	alert('Hello jo!');
});


var XFooProto = Object.create(HTMLElement.prototype);

XFooProto.createdCallback = function() {
  this.innerHTML = "<b>I'm an x-foo-with-markup!</b>";
};

var XFoo = document.registerElement('x-foo-with-markup', {prototype: XFooProto});

</script>




</body>
</html>
